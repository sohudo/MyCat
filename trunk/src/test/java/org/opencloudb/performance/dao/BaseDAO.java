package org.opencloudb.performance.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;

import org.opencloudb.performance.dao.ConnectionManager.ConnLevel;

/**
 * 数据访问DAO抽象类
 * 采用C3P0数据库连接池
 * @author shenzhw
 * 
 */
abstract class BaseDAO {
	/**
	 * 数据库连接
	 */
	private Connection conn = null;

	/**
	 * 预编译对象队列
	 */
	private ArrayList<PreparedStatement> statementList;

	/**
	 * 构造函数
	 * 
	 * @throws Exception
	 */
	protected BaseDAO() {
		// 初始化预编译及数据集队列
		statementList = new ArrayList<PreparedStatement>();
	}

	/**
	 * 获取数据库连接
	 * 
	 * @param ConnLevel
	 *            pLevel 数据库连接级别
	 * @throws Exception
	 */
	public void getConnection(ConnLevel pLevel) throws Exception {
		// 检查当前连接状态并关闭活动连接
		this.close();
		// 根据条件获取普通连接或Vip连接
		if (pLevel == ConnLevel.vip) {
			this.conn = ConnectionManager.getVipConnection();
		} else {
			this.conn = ConnectionManager.getNormalConnection();
		}
	}

	/**
	 * 返回当前数据库连接
	 * 
	 * @return Connection 当前DAO带事务的连接
	 * @throws SQLException
	 * 
	 */
	public Connection getCurrentConnection() throws SQLException {
		Connection currentConn = null;

		// 当前数据库连接是否可用并且自动提交关闭
		if (this.checkConnection() == true && this.conn.getAutoCommit() == false) {
			currentConn = this.conn;
		} else {
			throw new SQLException("当前连接不可用或未关闭自动提交");
		}

		return currentConn;
	}

	/**
	 * 获取外部连接，自动提交状态必须为false
	 * 
	 * @param Connection
	 *            外部连接
	 * @throws SQLException
	 * 
	 */
	public void setCurrentConnection(Connection pConn) throws SQLException {
		// 当外部连接不为空，未关闭，并接自动提交状态为false时赋值
		if (pConn != null && pConn.isClosed() == false && pConn.getAutoCommit() == false) {
			this.conn = pConn;
		} else {
			throw new SQLException("获取连接不可用或未关闭自动提交");
		}
	}

	/**
	 * 关闭使用的预编译对象及当前数据库连接
	 * 
	 * @throws SQLException
	 * 
	 */
	public void close() {
		try {
			// 数据库连接是否可用
			if (this.checkConnection() == true) {
				// 遍历关闭预编译对象
				for (PreparedStatement statement : this.statementList) {
					if (statement != null) {
						statement.close();
					}
				}
				// 清空预编译对象队列
				this.statementList.clear();
			}
			this.conn.close();
		} catch (Exception e) {
			// e.printStackTrace();
		}
	}

	/**
	 * 检查当前数据库连接是否可用
	 * 
	 * @return boolean 当前数据库连接是否可用
	 * @throws SQLException
	 */
	public boolean checkConnection() throws SQLException {
		boolean inUse = false;
		// 数据库连接是否不为空并且未关闭
		if (this.conn != null && !this.conn.isClosed()) {
			inUse = true;
		}
		return inUse;
	}

	/**
	 * 设置数据库自动提交
	 * 
	 * @throws SQLException
	 * 
	 */
	public void beginTransAction() throws SQLException {
		// 数据库连接是否可用,并且为自动提交
		if (this.checkConnection() == true && this.conn.getAutoCommit() == true) {
			// 取消当前连接的自动提交状态
			this.conn.setAutoCommit(false);
		}
	}

	/**
	 * 提交当前事务
	 * 
	 * @throws SQLException
	 * 
	 */
	public void commitTransAction() throws SQLException {
		// 数据库连接是否可用并且自动提交状态为fasle
		if (this.checkConnection() == true && this.conn.getAutoCommit() == false) {
			// 提交事务
			this.conn.commit();
			// 设置自动提交状态
			this.conn.setAutoCommit(true);
		}
	}

	/**
	 * 设置数据库自动提交
	 * 
	 * @throws SQLException
	 * 
	 */
	public void rollbackTransAction() throws SQLException {
		// 数据库连接是否可用并且自动提交状态为fasle
		if (this.checkConnection() == true && this.conn.getAutoCommit() == false) {
			// 回滚事务
			this.conn.rollback();
			// 设置自动提交状态
			this.conn.setAutoCommit(true);
		}
	}

	/**
	 * 获取自动提交状态
	 * 
	 * @return 自动提交状态
	 * @throws SQLException
	 */
	public boolean getAutoCommit() throws SQLException {
		return this.conn.getAutoCommit();
	}

	/************************** 自定义PrepareStatement方法 *************************/
	/**
	 * 创建一个 PreparedStatement 对象来将参数化的 SQL 语句发送到数据库
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql);
		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}

	/**
	 * 创建一个默认 PreparedStatement 对象，该对象能检索自动生成的键
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * @param int pAutoGeneratedKeys 指示是否应该返回自动生成的键的标志， 它是
	 *        Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS 之一
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql, int pAutoGeneratedKeys) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql, pAutoGeneratedKeys);

		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}

	/**
	 * 创建一个能够返回由给定数组指定的自动生成键的默认 PreparedStatement 对象
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * @param int[] pColumnIndexes 指示应该从一个或多个插入行中返回的那些列的列索引组成的数组
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql, int[] pColumnIndexes) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql, pColumnIndexes);

		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}

	/**
	 * 创建一个 PreparedStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * @param int pResultSetType 结果集类型，它是 ResultSet.TYPE_FORWARD_ONLY、
	 *        ResultSet.TYPE_SCROLL_INSENSITIVE 或
	 *        ResultSet.TYPE_SCROLL_SENSITIVE 之一
	 * @param int pResultSetConcurrency 并发类型，它是 ResultSet.CONCUR_READ_ONLY 或
	 *        ResultSet.CONCUR_UPDATABLE 之一
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql, int pResultSetType, int pResultSetConcurrency) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql, pResultSetType, pResultSetConcurrency);

		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}

	/**
	 * 创建一个 PreparedStatement 对象，该对象将生成具有给定类型、并发性和可保存性的 ResultSet 对象
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * @param int pResultSetType 以下 ResultSet 常量之一：ResultSet.TYPE_FORWARD_ONLY、
	 *        ResultSet.TYPE_SCROLL_INSENSITIVE 或
	 *        ResultSet.TYPE_SCROLL_SENSITIVE
	 * @param int pResultSetConcurrency 以下 ResultSet
	 *        常量之一：ResultSet.CONCUR_READ_ONLY 或 ResultSet.CONCUR_UPDATABLE
	 * @param int pResultSetHoldability 以下 ResultSet 常量之一：
	 *        ResultSet.HOLD_CURSORS_OVER_COMMIT 或
	 *        ResultSet.CLOSE_CURSORS_AT_COMMIT
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql, int pResultSetType, int pResultSetConcurrency, int pResultSetHoldability) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql, pResultSetType, pResultSetConcurrency, pResultSetHoldability);

		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}

	/**
	 * 创建一个能够返回由给定数组指定的自动生成键的默认 PreparedStatement 对象
	 * 
	 * @param String
	 *            pSql SQL 语句
	 * @param String
	 *            [] pColumnNames 指示应该从一个或多个插入行中返回的那些列的列名称组成的数组
	 * 
	 * @throws SQLException
	 * 
	 */
	public PreparedStatement prepareStatement(String pSql, String[] pColumnNames) throws SQLException {
		// 创建预编译对象
		PreparedStatement statement = this.conn.prepareStatement(pSql, pColumnNames);

		// 添加到预编译对象队列
		this.statementList.add(statement);

		return statement;
	}
}
